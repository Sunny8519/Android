#### 同步(Synchronous)和异步(Asynchronous)

同步和异步通常用来形容一次方法调用，同步方法调用是指一旦方法被调用，调用者就必须等到被调用方法返回才能继续下面代码的执行，异步方法调用则是指方法被调用后立即返回，调用者继续干它自己的事情，被调用者则在另一个线程中执行自己的代码，两者互不干扰。

#### 并发(Concurrency)和并行(Parallelism)

并行是真正意义上的同时执行，即在同一时刻CPU在执行不同的代码(对于多核CPU或者多CPU)，而并发则是同一时刻一个单核CPU只能执行一条指令，操作系统在一定时间(时间非常短)内不断切换任务执行，给人的感觉跟并行没有什么区别。

PS:个人感觉并发和并行还是与很大区别的，既然并行是真正意义上的同时执行，那么执行两个相同任务并行所花费的时间肯定比并发要短(多个CPU同时做几件事和一个CPU切换着做几件事)。

#### 临界区

临界区用来表示一种公共资源或者共享数据，它可以被多个线程使用，**但同一时刻只能有一个线程使用它**，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。

#### 阻塞与非阻塞

阻塞与非阻塞描述的是多个线程之间的相互影响。比如一个线程占用了临界区的资源，此时其他线程也想使用这个临界区的资源，就需要等待了，等待会导致线程被挂起，这种情况我们就称为阻塞(一个线程影响了其他线程)。非阻塞的意思就与阻塞相反，它强调的是没有一个线程能够影响其他线程的执行，所有线程都会尝试不断的向前执行。

#### 死锁(Deadlock)、饥饿(Starvation)和活锁(Livelock)

死锁、饥饿和活锁都属于多线程活跃性问题。

死锁：假如我们现在有两个线程A，B，有两个临界区资源c，d，此时线程A占用了资源c，又需要资源d去做一些事情，而线程B占用了资源d，又需要资源c去做一些事情，这时我们就发现线程A一直在等待资源d，而线程B则一直在等待资源c，两个线程都不往下执行了，一直处于挂起(阻塞)状态，这种线程就是死锁。

饥饿：饥饿可能会表现为两种情况，第一种是线程优先级特别低，而线程优先级高的线程又在疯狂执行，这就会导致优先级低的线程在一段时间内一直得不到执行，这是一种线程饥饿的表现；另一种是某个线程一直占用着资源，而其他需要这个资源的线程一直处于等待状态，不能正常执行，这也是线程饥饿的表现。

活锁：电梯的例子，如果你从电梯出来，刚好外面一个人挡着你出去的路了，他想进电梯，这时你很绅士的向左靠让他走，但是对方也很绅士，他向右靠，想让你走，这时就会发现你俩又撞上了，然后你再向右靠让他走，他也向左靠让你走，你俩又撞上了...基于人类的智商，这种情况碰上两次之后，你俩通过交流就能很好的解决。但是在程序中，线程的智力并不高，如果线程都秉着“谦让”的原则，主动将资源释放给他人使用，就会出现资源在两个线程之间不断跳动，而没有一个线程能拿到所有资源而正常执行。

