### 依赖倒置原则(DIP)

#### 高层(上层)和低层(下层)的理解
可以简单的理解为调用者为高层(上层)，被调用者为低层(下层)，比如class A中有对class B的引用，可能为强引用(类成员变量)，或者Class B作为class A中方法的参数或者局部变量，这些情况下，class A可以叫做高层模块，class B叫做低层模块，class A中使用到了class B。

理解了这两个概念之后应该更容易理解依赖倒置原则了。

#### 依赖倒置原则的三层含义
- 高层模块不应该直接依赖于低层模块，应该依赖于低层模块的抽象(抽象类或接口)
- 抽象不应该依赖于细节
- 细节应该依赖于抽象(抽象类或接口)

在Java语言中，抽象就是指抽象类或接口，它们是不能被实例化的，细节就是具体的实现类，那么上面的三层含义在Java语言中的应用就是：
- 模块间的依赖是通过抽象发生，实现类之间不发生直接依赖关系
- 抽象类或接口不依赖于具体的实现类
- 实现类依赖于抽象类或接口

这种思想就是面向接口编程(OOD)

#### DIP几种写法
1.抽象高层和低层模块(或者只抽象低层模块)，通过构造函数传递依赖对象(构造器注入)：
```
// 汽车接口
public interface ICar {

    void run();
}

// 驾驶员接口
public interface IDriver {

    void drive();
}

// 驾驶员实现类调用汽车对象
public class XiaoMing implements IDriver {

    private ICar mCar;

    // 通过构造器注入对象
    public XiaoMing(ICar car) {
        this.mCar = car;
    }

    @Override
    public void drive() {
        this.mCar.run();
    }
}
```

2.在申明接口的同时也申明依赖对象
```
// 汽车接口
public interface ICar {

    void run();
}

// 驾驶员接口
public interface IDriver {

    void drive(ICar car); // 申明依赖对象
}

// 驾驶员实现类调用汽车对象
public class XiaoMing implements IDriver {

    @Override
    public void drive(ICar car) {
        car.run();
    }
}
```

3.通过setter方法依赖对象
```
// 汽车接口
public interface ICar {

    void run();
}

// 驾驶员接口
public interface IDriver {

    void drive();
}

// 驾驶员实现类调用汽车对象
public class XiaoMing implements IDriver {

    private ICar mCar;

    // 通过setter方法注入依赖对象
    public void setCar(ICar car) {
        this.mCar = car;
    }

    @Override
    public void drive() {
        this.mCar.run();
    }
}
```

#### 疑问
1.依赖倒置原则中所谓的倒置体现在哪儿？
从上面一大段的介绍中并没有体现依赖的“倒置”到底在哪儿，更多的感受是这个原则其实就是面向接口编程，把原来依赖于具体实现类的方式改为了依赖抽象，即抽象依赖原则，并没有所谓的“倒置”。