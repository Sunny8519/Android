## 线程的基本概念

一条线程表示一条单独的执行流，它有自己的程序计数器以及栈。

创建线程有四种方式：
- 继承Thread类，实现run()方法；
- 实现Runnable接口，再把实现了Runnable接口的对象注入到Thread对象中；
- 实现Callable接口，通过FutureTask包装器注入Thread对象；
- 通过ExecutorService,Callable,FutureTask实现有返回结果的多线程:Executors提供了多个生成ExecutorService的工厂方法。

### 线程的基本属性和方法

Thread有一个静态方法可以获取到当前正在执行的线程对象：
```java
public static native Thread currentThread()
```

#### id和name
每个线程都有id和name:
```java
public long getId()
public final String getName()
```

#### 优先级

线程中的优先级概念只是起到一个建议的作用，换句话说就是给线程设置优先级之后能不能生效取决于当前操作系统。

Java中线程优先级从1到10，默认是5，值越大表示优先级越高。

相关方法：
```java
public final void setPriority(int newPriority)
public final int getPriority()
```

#### 状态

Thread中获取状态的方法：
```java
public Thread.State getState()
```

该方法返回值是Thread.State，它是一个枚举：
```java
public enum State{
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}
```

#### 线程是否还活着

```java
public final native boolean isAlive();
```

该方法在线程启动到run方法运行完之前都会返回true。

#### 是否是daemo线程

Thread中有一个是否是daemo线程的属性：

```java
public final void setDaemo(boolean isDaemo);
public final boolean isDaemo();
```

daemo线程属于辅助线程，比如我们启动一个main线程，那么相应的，最少会有一个垃圾回收线程作为daemo线程，当程序中只剩下daemo线程时，程序才会退出。

#### yield方法

```java
public static native void yield();
```

该方法的作用是告知操作系统调度器，当前线程暂时不需要占用CPU，可以让其他线程先执行，但是具体调度器会如何决策，无法确定。

#### join方法

```java
public final void join() throws InterruptedException
public final synchronized void join(long wating) throws InterruptedException
```

join方法会让调用线程处于阻塞状态，等待执行线程执行完毕。

### 共享内存问题

#### 竞态条件

竞态条件是指当多个线程访问和操作同一个对象时，最终执行结果与执行时序有关，结果可能是正确的，也可能是不正确的。

`count++`并不是原子操作，这一行代码实际包含三个原子操作，分别是取count值，count值加1以及给count赋值。

#### 内存可见性

内存可见性是指在多个线程对同一个变量进行访问和操作时，一个线程修改了变量的值，另一个线程不能及时看到甚至永远也看不到。

发生内存可见性的原因：

CPU和内存的存取速度是有很大差异的，通常内存的存取速度跟不上CPU的运算速度，那么每次运算的数据都从内存读取然后写入内存，就会发生由于内存存取速度慢而拖累了CPU的运算速度，为了解决这个问题，计算机在设计时，就设计了各种寄存器以及缓存，寄存器和缓存的读取速度要远远快于内存，这样才能维持CPU的高速运转，同时会带来一个问题，在CPU中运算完的数据可能不会及时同步到内存中，这样，另一个CPU也在执行一个线程，访问的是同一个变量，此时它得到的并不是最新的变量值(最新的还在寄存器或者缓存中)，这就是内存可见性的问题，如果出现内存可见性问题，那么程序运算结果往往都不是我们期望的。

#### 线程上下文切换

在多线程环境下，线程调度器在进行线程切换时是有开销的，其中一部分开销就是线程上下文的保存，线程在切换过程中，操作系统会把当前上下文状态保存到内存中，上下文状态包括当前CPU寄存器中的值、程序计数器的值等。当线程切换回来时，需要把该线程的上下文状态恢复。